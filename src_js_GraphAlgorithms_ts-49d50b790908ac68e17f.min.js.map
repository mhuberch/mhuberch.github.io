{"version":3,"file":"src_js_GraphAlgorithms_ts-49d50b790908ac68e17f.min.js","mappings":"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","sources":["webpack://graphPlayground/./src/js/GraphAlgorithms.ts","webpack://graphPlayground/./src/js/classes/SpanningTree.ts"],"sourcesContent":["\"use strict\";\n\nimport genericH from \"./util/genericHelpers\";\nimport graphH from \"./util/graphHelpers\";\nimport SpanningTree from \"./classes/SpanningTree\";\nimport EdgeImmut, { EdgeImmutPlain } from \"./classes/GraphImmut/EdgeImmut\";\nimport NodeImmut from \"./classes/GraphImmut/NodeImmut\";\nimport GraphImmut from \"./classes/GraphImmut/GraphImmut\";\nimport GraphState from \"./graphState\";\nimport { GraphPlain } from \"./util/predefinedGraphs\";\n\ntype EdgeFlowProp = { from: number; to: number; capacity: number; flow: number };\nexport type MSTResult = { mst: EdgeImmutPlain[]; totalWeight: number };\nexport type FlowResult = { maxFlow: number; flowPath: EdgeFlowProp[] };\nexport type ShortestPathResult = {\n    pathExists: boolean;\n    path: number[];\n    distance: number;\n    cost?: number;\n    weight?: number;\n};\nexport type ConnectedComponentResult = { components: { [key: number]: number }; count: number };\n\nexport type CheckingColorResult = { from: number[]; to: number[]; num: number; confList: number[][]};\n\nexport type kColorResult = { kcolor: number; kcolorable: boolean; color: number[]};\n\nexport type kColorResultRecursive = { kcolorable: boolean; color: number[]};\n\nexport default class GraphAlgorithms {\n    public static graphPlainToGraphImmut = (gp: GraphPlain): GraphImmut => {\n        return new GraphImmut(gp.nodes, gp.edges, gp.directed, gp.weighted);\n    };\n\n\n    // // Coloring with brute force\n    // public static colorBruteForce = (G: GraphImmut = GraphState.graph) : {colors: {}; chromaticNumber: number} => {\n\n    //     // start with degree + 1\n\n    //     // check if k-colorable with brute force\n\n    // }\n\n    // Check, if a coloring is admissible\n    public static checkColoringByString = (G: GraphImmut = GraphState.graph): CheckingColorResult => {\n\n        const nodes = G.getAllNodes(true) as NodeImmut[];\n\n        const conflictStartID: number[] = [];\n        const conflictEndID: number[] = [];\n        const conflictList : number[][] = [];\n\n\n        const V = G.getNumberOfNodes();\n        for (let v = 0; v < V; v++) {\n            const vertexAdjacency = G.getNodeAdjacency(v);\n            const currentColor = nodes[v].getAttribute('color');\n\n            //console.log(\"Vertex with ID\" + v);\n            //console.log(\"has adjacency: \" + vertexAdjacency);\n\n            for (const i of vertexAdjacency) {\n                const conflict  = graphH.compareColor(currentColor, nodes[i].getAttribute('color'));\n                if (conflict && i > v) {\n                    conflictStartID.push(v);\n                    conflictEndID.push(i);\n                    conflictList.push([v, i]);\n                }\n            }\n        }\n        \n        const numOfConflicts = conflictStartID.length;\n\n        return { from: conflictStartID, to: conflictEndID,  num: numOfConflicts, confList: conflictList};\n\n    }\n\n    public static checkColoringByNumber = (color: number[], G: GraphImmut = GraphState.graph): boolean => {\n\n        const nodes = G.getAllNodes(true) as NodeImmut[];\n\n        const V = G.getNumberOfNodes();\n        for (let v = 0; v < V; v++) {\n            const vertexAdjacency = G.getNodeAdjacency(v);\n            const currentColor = color[v];\n\n            for (const i of vertexAdjacency) {\n                const conflict  = (currentColor === color[i]);\n                if (conflict && i > v) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n\n    }\n\n    // Welsh-Powell Algorithm\n    public static colorNetworkWelsh = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number } => {\n        // Get node ID's only\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\n\n        // Put vertices in array in decreasing order of degree\n        const degrees = G.getAllOutDegrees();\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\n        });\n\n        const colorIndex: { [key: number]: number } = {};\n        let currentColor = 0;\n        while (vertexOrder.length > 0) {\n            const root = vertexOrder.shift()!;\n            colorIndex[root] = currentColor;\n\n            const myGroup = [];\n            myGroup.push(root);\n\n            for (let i = 0; i < vertexOrder.length; ) {\n                const p = vertexOrder[i];\n                let conflict = false;\n\n                for (let j = 0; j < myGroup.length; j++) {\n                    if (G.areAdjacent(p, myGroup[j])) {\n                        i++;\n                        conflict = true;\n                        break;\n                    }\n                }\n                if (conflict) {\n                    continue;\n                }\n\n                colorIndex[p] = currentColor;\n                myGroup.push(p);\n                vertexOrder.splice(i, 1);\n            }\n\n            currentColor++;\n        }\n\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\n        return { colors: colorIndex, chromaticNumber };\n    };\n\n    \n\n    public static kColoringBruteForce = (kcolor: number, G: GraphImmut = GraphState.graph): kColorResult => {\n        // export type kColorResult = { kcolor: number; kcolorable: boolean; color: number[]};\n    \n        console.log(\"Hi there. I'm kColoringBruteForce\");\n\n        const V = G.getNumberOfNodes();\n\n        const color = new Array(V).fill(0);\n\n        const recAnswer = this.kColoringBruteForceRecursive(kcolor, 0, color)\n\n        if (recAnswer.kcolorable) {\n            return { kcolor, kcolorable: true, color: recAnswer.color };\n        }\n\n        return { kcolor, kcolorable: false, color: []};\n    }\n\n    public static kColoringBruteForceRecursive = (kcolor: number, curNode: number, color: number[], G: GraphImmut = GraphState.graph): kColorResultRecursive => {\n        //function graphColoring(graph,m,i,color)\n        // {\n        const V = G.getNumberOfNodes();\n        \n        if (curNode === V) {\n            const check = this.checkColoringByNumber(color);\n            if (check) {            \n                return { kcolorable: true, color };\n            }\n            else {\n                return { kcolorable: false, color: [] };\n            }\n        }\n\n        for (let j=1; j <= kcolor; j++) {\n            color[curNode] = j;\n\n            const recAnswer = this.kColoringBruteForceRecursive(kcolor, curNode+1, color);\n\n            if (recAnswer.kcolorable) {\n                return recAnswer;\n            }\n\n            color[curNode] = 0;\n\n        }\n\n        return { kcolorable: false, color: []};\n\n    }\n    \n\n\n    public static connectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n        const setComponentNum = (v: number) => {\n            components[v] = componentCount;\n        };\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in components)) {\n                const visited = GraphAlgorithms.depthFirstSearch(i, G);\n                visited.forEach(setComponentNum);\n                componentCount++;\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static depthFirstSearch = (start: number, G = GraphState.graph): number[] => {\n        const visisted: number[] = [];\n        const Stack: number[] = [];\n        Stack.push(start);\n        while (Stack.length > 0) {\n            const v = Stack.pop()!;\n            if (!visisted.includes(v)) {\n                visisted.push(v);\n                G.getNodeAdjacency(v).forEach(nodeID => {\n                    Stack.push(nodeID);\n                });\n            }\n        }\n\n        return visisted;\n    };\n\n    // Tarjan's algorithm\n    public static stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        let index = 0;\n        const indices: { [key: number]: number } = {};\n        const lowlink: { [key: number]: number } = {};\n        const S: number[] = [];\n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n\n        const strongConnect = (v: number) => {\n            indices[v] = index;\n            lowlink[v] = index++;\n            S.push(v);\n\n            G.getNodeAdjacency(v).forEach(w => {\n                if (!(w in indices)) {\n                    strongConnect(w);\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\n                } else if (S.includes(w)) {\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\n                }\n            });\n\n            if (lowlink[v] === indices[v]) {\n                let w = -1;\n                if (S.length > 0) {\n                    do {\n                        w = S.pop()!;\n                        components[w] = componentCount;\n                    } while (w !== v);\n                    componentCount++;\n                }\n            }\n        };\n\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in indices)) {\n                strongConnect(i);\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static breadthFirstSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult => {\n        // Perform the BFS\n        const visisted: number[] = [];\n        const Q: number[] = []; // Use Push and Shift for Queue operations\n        const edgeTo: { [key: number]: number } = {};\n\n        Q.push(startNodeID);\n        while (Q.length > 0) {\n            const x = Q.shift()!;\n            if (!visisted.includes(x)) {\n                visisted.push(x);\n                G.getNodeAdjacency(x).forEach(y => {\n                    if (!visisted.includes(y)) {\n                        edgeTo[y] = x;\n                        Q.push(y);\n                    }\n                });\n            }\n        }\n\n        if (visisted.includes(targetNodeID)) {\n            // Build the path\n            const path = [];\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\n                path.push(x);\n            }\n            path.push(startNodeID);\n            path.reverse();\n\n            // Get the path weight\n            let weight = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\n            }\n\n            return { pathExists: true, path, distance: path.length, weight };\n        }\n\n        return { pathExists: false, path: [], distance: -1, weight: -1 };\n    };\n\n    public static dijkstraSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        if (!G.isDirected()) {\n            G = G.asDirected(true);\n        }\n        if (!G.isWeighted()) {\n            G = G.asWeighted();\n        }\n\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find(edge => {\n            return edge.getWeight() < 0;\n        });\n        if (typeof nonNegative !== \"undefined\") {\n            return false;\n        }\n\n        // Priority Queue implementation for Dijkstra\n        class PriorityQueue {\n            private readonly _nodes: { key: number | string; priority: number }[] = [];\n\n            enqueue(priority: number, key: number): void {\n                this._nodes.push({ key, priority });\n                this.sort();\n            }\n\n            dequeue(): number | string {\n                return this._nodes.shift()!.key;\n            }\n\n            sort(): void {\n                this._nodes.sort((a: { priority: number }, b: { priority: number }) => {\n                    return a.priority - b.priority;\n                });\n            }\n\n            isEmpty(): boolean {\n                return !this._nodes.length;\n            }\n        }\n\n        const queue = new PriorityQueue();\n        const distances: { [key: number]: number } = {};\n        const previous: { [key: number]: number | null } = {};\n        let path = [];\n\n        // Initialize Queue and distances\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            let dist = Infinity;\n            if (node.getID() === startNodeID) {\n                dist = 0;\n            }\n\n            distances[node.getID()] = dist;\n            queue.enqueue(dist, node.getID());\n            previous[node.getID()] = null;\n        });\n\n        while (!queue.isEmpty()) {\n            let smallest = queue.dequeue() as number;\n\n            if (smallest === targetNodeID) {\n                path = [];\n                while (previous[smallest] !== null) {\n                    path.push(smallest);\n                    smallest = previous[smallest]!;\n                }\n                break;\n            }\n\n            if (distances[smallest] === Infinity) {\n                continue;\n            }\n\n            G.getNodeAdjacency(smallest).forEach(neighbor => {\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\n\n                if (alt < distances[neighbor]) {\n                    distances[neighbor] = alt;\n                    previous[neighbor] = smallest;\n\n                    queue.enqueue(alt, neighbor);\n                }\n            });\n        }\n\n        path.push(startNodeID);\n        path.reverse();\n\n        if (distances[targetNodeID] !== Infinity) {\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static bellmanFord = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        const distances: number[] = [];\n        const parents: (number | null)[] = [];\n\n        // Initialize\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            distances[node.getID()] = Infinity;\n            parents[node.getID()] = null;\n        });\n\n        // Relax Edges\n        distances[startNodeID] = 0;\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\n            (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\n                    parents[edge.getTo()] = edge.getFrom();\n                }\n            });\n        }\n\n        // Check for negative weight cycles\n        let negativeCylce = false;\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                negativeCylce = true;\n            }\n        });\n\n        if (distances[targetNodeID] !== Infinity) {\n            const path: number[] = [targetNodeID];\n            while (!path.includes(startNodeID)) {\n                path.push(parents[path.slice().pop()!] as number);\n            }\n            path.reverse();\n\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        if (negativeCylce) {\n            return false;\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static fordFulkerson = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): boolean | FlowResult => {\n        // Must be a directed graph\n        if (!G.isDirected()) {\n            return false;\n        }\n\n        // Source == sink\n        if (startNodeID === targetNodeID) {\n            return false;\n        }\n\n        const bfs = GraphAlgorithms.breadthFirstSearch(startNodeID, targetNodeID, G);\n        // No path from source to sink\n        if (!bfs.pathExists) {\n            return false;\n        }\n\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\n        G = G.reduceMultiGraph((a, b) => {\n            return a + b;\n        }, 0);\n\n        const V = G.getNumberOfNodes();\n        let value = 0;\n        let marked: boolean[] = [];\n        let edgeTo: (string | null)[] = [];\n\n        const edgeProperties: { [key: string]: EdgeFlowProp } = {};\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\n                from: edge.getFrom(),\n                to: edge.getTo(),\n                capacity: edge.getWeight(),\n                flow: 0\n            };\n        });\n\n        const other = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            const b = parseInt(edge[1]);\n            return x === a ? b : a;\n        };\n\n        const residualCapacity = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            if (x === a) {\n                return edgeProperties[e].flow;\n            }\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\n        };\n\n        const addResidualFlow = (e: string, x: number, deltaFlow: number) => {\n            const edge = e.split(\"_\");\n            const v = parseInt(edge[0]);\n            if (x === v) {\n                edgeProperties[e].flow -= deltaFlow;\n            } else {\n                edgeProperties[e].flow += deltaFlow;\n            }\n        };\n\n        const hasAugmentedPath = () => {\n            marked = [];\n            edgeTo = [];\n            for (let v = 0; v < V; ++v) {\n                marked.push(false);\n                edgeTo.push(null);\n            }\n\n            const queue = [];\n            queue.push(startNodeID);\n\n            marked[startNodeID] = true;\n            while (queue.length > 0) {\n                const v = queue.shift()!;\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    const w = other(e, v);\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\n                        edgeTo[w] = e;\n                        marked[w] = true;\n                        if (w === targetNodeID) {\n                            return true;\n                        }\n\n                        queue.push(w);\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        while (hasAugmentedPath()) {\n            let bottleneckValue = Infinity;\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x]!, x));\n            }\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                addResidualFlow(edgeTo[x]!, x, bottleneckValue);\n            }\n            value += bottleneckValue;\n        }\n\n        const getFlows = (): EdgeFlowProp[] => {\n            const f: EdgeFlowProp[] = [];\n            for (let v = 0; v < V; v++) {\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    if (edgeProperties[e].flow > 0) {\n                        f.push(edgeProperties[e]);\n                    }\n                }\n            }\n\n            return f;\n        };\n\n        return { maxFlow: value, flowPath: getFlows() };\n    };\n\n    public static kruskal = (G: GraphImmut = GraphState.graph): MSTResult => {\n        // If we have a multigraph, reduce it by using the minimum edge weights\n        G.reduceMultiGraph();\n\n        const Q: EdgeImmut[] = G.getAllEdges(true) as EdgeImmut[];\n\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\n        Q.sort((a, b) => {\n            return a.getWeight() - b.getWeight();\n        });\n\n        const kruskal: EdgeImmut[] = [];\n        const set = new SpanningTree(G.getNumberOfNodes());\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\n            const e = Q.shift()!;\n            if (!set.connected(e.getFrom(), e.getTo())) {\n                set.union(e.getFrom(), e.getTo());\n                kruskal.push(e);\n            }\n        }\n\n        // Get the total cost of the MST\n        const weight = kruskal.reduce((acc, e) => {\n            return acc + e.getWeight();\n        }, 0);\n\n        return { mst: (kruskal as any) as EdgeImmutPlain[], totalWeight: weight };\n    };\n\n    public static topologicalSort = (G: GraphImmut = GraphState.graph): boolean | NodeImmut[] => {\n        const adjacency = G.getFullAdjacency();\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\n\n        const L: NodeImmut[] = [];\n        const S: NodeImmut[] = (G.getAllNodes(true) as NodeImmut[]).filter(n => {\n            return degrees[n.getID()].in === 0;\n        });\n        let edges = G.getAllEdges(true) as EdgeImmut[];\n\n        while (S.length !== 0) {\n            const nodeN = S.pop()!;\n            L.push(nodeN);\n\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\n\n            // Remove n to m edges for all nodes m\n            edges = edges.filter(edge => {\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\n                    degrees[edge.getTo()].in--;\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter(v => {\n                        return v !== edge.getTo();\n                    });\n                    return false;\n                }\n                return true;\n            });\n\n            // If m has no more incoming edges, add it to S\n            nodeNConnectedTo.forEach(mID => {\n                if (degrees[mID].in === 0) {\n                    S.push(G.getNode(mID, true) as NodeImmut);\n                }\n            });\n        }\n\n        return edges.length > 0 || L;\n    };\n\n    public static isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\n        return GraphAlgorithms.topologicalSort(G) === true;\n    };\n\n    public static directionalEulerian = (directionalDegrees: { in: number; out: number }[], scc: number[]): boolean => {\n        let eulerian = true;\n        let component = -1;\n        directionalDegrees.forEach((deg, id) => {\n            if (deg.in !== deg.out) {\n                eulerian = false;\n            }\n            if (deg.in > 0) {\n                if (component === -1) {\n                    component = scc[id];\n                }\n                if (component !== scc[id]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n\n    public static hasEulerianCircuit = (degrees: number[], cc: number[]): boolean => {\n        const oddDegree = degrees.filter(v => {\n            return v % 2 !== 0;\n        });\n\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\n        if (oddDegree.length !== 0) {\n            return false;\n        }\n\n        let eulerian = true;\n        let component = -1;\n        degrees.forEach((v, i) => {\n            if (v !== 0) {\n                if (component === -1) {\n                    component = cc[i];\n                }\n                if (component !== cc[i]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n}\n","\"use strict\";\n\nexport default class SpanningTree {\n    private readonly id: number[];\n\n    constructor(V: number) {\n        this.id = [];\n        for (let v = 0; v < V; v++) {\n            this.id.push(v);\n        }\n    }\n\n    union(v: number, w: number) {\n        const q = this.root(v);\n        const p = this.root(w);\n\n        if (p !== q) {\n            this.id[p] = q;\n        }\n    }\n\n    root(q: number) {\n        while (this.id[q] !== q) {\n            q = this.id[q];\n        }\n        return q;\n    }\n\n    connected(v: number, w: number) {\n        return this.root(v) === this.root(w);\n    }\n}\n"],"names":[],"sourceRoot":""}