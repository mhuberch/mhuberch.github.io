"use strict";
(self["webpackChunkgraphPlayground"] = self["webpackChunkgraphPlayground"] || []).push([["src_js_GraphAlgorithms_ts"],{

/***/ "./src/js/GraphAlgorithms.ts":
/*!***********************************!*\
  !*** ./src/js/GraphAlgorithms.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_genericHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/genericHelpers */ "./src/js/util/genericHelpers.ts");
/* harmony import */ var _util_graphHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/graphHelpers */ "./src/js/util/graphHelpers.ts");
/* harmony import */ var _classes_SpanningTree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/SpanningTree */ "./src/js/classes/SpanningTree.ts");
/* harmony import */ var _classes_GraphImmut_GraphImmut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/GraphImmut/GraphImmut */ "./src/js/classes/GraphImmut/GraphImmut.ts");
/* harmony import */ var _graphState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphState */ "./src/js/graphState.ts");







var GraphAlgorithms = /** @class */ (function () {
    function GraphAlgorithms() {
    }
    GraphAlgorithms.graphPlainToGraphImmut = function (gp) {
        return new _classes_GraphImmut_GraphImmut__WEBPACK_IMPORTED_MODULE_3__["default"](gp.nodes, gp.edges, gp.directed, gp.weighted);
    };
    // // Coloring with brute force
    // public static colorBruteForce = (G: GraphImmut = GraphState.graph) : {colors: {}; chromaticNumber: number} => {
    //     // start with degree + 1
    //     // check if k-colorable with brute force
    // }
    // Check, if a coloring is admissible
    GraphAlgorithms.checkColoringByString = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var nodes = G.getAllNodes(true);
        var conflictStartID = [];
        var conflictEndID = [];
        var conflictList = [];
        var V = G.getNumberOfNodes();
        for (var v = 0; v < V; v++) {
            var vertexAdjacency = G.getNodeAdjacency(v);
            var currentColor = nodes[v].getAttribute('color');
            //console.log("Vertex with ID" + v);
            //console.log("has adjacency: " + vertexAdjacency);
            for (var _i = 0, vertexAdjacency_1 = vertexAdjacency; _i < vertexAdjacency_1.length; _i++) {
                var i = vertexAdjacency_1[_i];
                var conflict = _util_graphHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].compareColor(currentColor, nodes[i].getAttribute('color'));
                if (conflict && i > v) {
                    conflictStartID.push(v);
                    conflictEndID.push(i);
                    conflictList.push([v, i]);
                }
            }
        }
        var numOfConflicts = conflictStartID.length;
        return { from: conflictStartID, to: conflictEndID, num: numOfConflicts, confList: conflictList };
    };
    // Welsh-Powell Algorithm
    GraphAlgorithms.colorNetworkWelsh = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        // Get node ID's only
        var nodeArr = _util_genericHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].datasetToArray(G.getAllNodes(), "id");
        // Put vertices in array in decreasing order of degree
        var degrees = G.getAllOutDegrees();
        var vertexOrder = _util_genericHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].sort(nodeArr, function (a, b) {
            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;
        });
        var colorIndex = {};
        var currentColor = 0;
        while (vertexOrder.length > 0) {
            var root = vertexOrder.shift();
            colorIndex[root] = currentColor;
            var myGroup = [];
            myGroup.push(root);
            for (var i = 0; i < vertexOrder.length;) {
                var p = vertexOrder[i];
                var conflict = false;
                for (var j = 0; j < myGroup.length; j++) {
                    if (G.areAdjacent(p, myGroup[j])) {
                        i++;
                        conflict = true;
                        break;
                    }
                }
                if (conflict) {
                    continue;
                }
                colorIndex[p] = currentColor;
                myGroup.push(p);
                vertexOrder.splice(i, 1);
            }
            currentColor++;
        }
        var chromaticNumber = _util_genericHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].max(_util_genericHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].flatten(colorIndex)) + 1;
        return { colors: colorIndex, chromaticNumber: chromaticNumber };
    };
    GraphAlgorithms.kColoringBruteForce = function (kColor, G) {
        // export type kColorResult = { kColor: number; kColorable: boolean; color: number[]};
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        console.log("Hi there. I'm kColoringBruteForce");
        console.log(_graphState__WEBPACK_IMPORTED_MODULE_4__["default"].state.kColorable);
        var kColoringBruteForceRecursive = function (kColor, curNode, color, G) {
            //function graphColoring(graph,m,i,color)
            // {
            var V = G.getNumberOfNodes();
            // console.log("CurNode: " + curNode + " with colors " + color);
            if (curNode === V) {
                var check = _util_graphHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].checkColoringByNumber(color, G);
                if (check) {
                    return { kColorable: true, color: color };
                }
                else {
                    return { kColorable: false, color: [] };
                }
            }
            for (var j = 1; j <= kColor; j++) {
                color[curNode] = j;
                var recAnswer_1 = kColoringBruteForceRecursive(kColor, curNode + 1, color, G);
                if (recAnswer_1.kColorable) {
                    return recAnswer_1;
                }
                color[curNode] = 0;
            }
            return { kColorable: false, color: [] };
        };
        // console.log("Graph " + G);
        var V = G.getNumberOfNodes();
        // console.log(V);
        var color = new Array(V).fill(0);
        // console.log("Soon starting the recursive algorithm. Start ")
        var recAnswer = kColoringBruteForceRecursive(kColor, 0, color, G);
        if (recAnswer.kColorable) {
            return { kColor: kColor, kColorable: true, color: recAnswer.color };
        }
        return { kColor: kColor, kColorable: false, color: [] };
    };
    // public static kColoringBruteForceRecursive = (kColor: number, curNode: number, color: number[], G: GraphImmut = GraphState.graph): kColorResultRecursive => {
    //     //function graphColoring(graph,m,i,color)
    //     // {
    //     const V = G.getNumberOfNodes();
    //     if (curNode === V) {
    //         const check = this.checkColoringByNumber(color);
    //         if (check) {            
    //             return { kColorable: true, color };
    //         }
    //         else {
    //             return { kColorable: false, color: [] };
    //         }
    //     }
    //     for (let j=1; j <= kColor; j++) {
    //         color[curNode] = j;
    //         const recAnswer = this.kColoringBruteForceRecursive(kColor, curNode+1, color);
    //         if (recAnswer.kColorable) {
    //             return recAnswer;
    //         }
    //         color[curNode] = 0;
    //     }
    //     return { kColorable: false, color: []};
    // }
    GraphAlgorithms.connectedComponents = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var components = {};
        var componentCount = 0;
        var setComponentNum = function (v) {
            components[v] = componentCount;
        };
        for (var i = 0; i < G.getNumberOfNodes(); i++) {
            if (!(i in components)) {
                var visited = GraphAlgorithms.depthFirstSearch(i, G);
                visited.forEach(setComponentNum);
                componentCount++;
            }
        }
        return { components: components, count: componentCount };
    };
    GraphAlgorithms.depthFirstSearch = function (start, G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var visisted = [];
        var Stack = [];
        Stack.push(start);
        while (Stack.length > 0) {
            var v = Stack.pop();
            if (!visisted.includes(v)) {
                visisted.push(v);
                G.getNodeAdjacency(v).forEach(function (nodeID) {
                    Stack.push(nodeID);
                });
            }
        }
        return visisted;
    };
    // Tarjan's algorithm
    GraphAlgorithms.stronglyConnectedComponents = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var index = 0;
        var indices = {};
        var lowlink = {};
        var S = [];
        var components = {};
        var componentCount = 0;
        var strongConnect = function (v) {
            indices[v] = index;
            lowlink[v] = index++;
            S.push(v);
            G.getNodeAdjacency(v).forEach(function (w) {
                if (!(w in indices)) {
                    strongConnect(w);
                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);
                }
                else if (S.includes(w)) {
                    lowlink[v] = Math.min(lowlink[v], indices[w]);
                }
            });
            if (lowlink[v] === indices[v]) {
                var w = -1;
                if (S.length > 0) {
                    do {
                        w = S.pop();
                        components[w] = componentCount;
                    } while (w !== v);
                    componentCount++;
                }
            }
        };
        for (var i = 0; i < G.getNumberOfNodes(); i++) {
            if (!(i in indices)) {
                strongConnect(i);
            }
        }
        return { components: components, count: componentCount };
    };
    GraphAlgorithms.breadthFirstSearch = function (startNodeID, targetNodeID, G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        // Perform the BFS
        var visisted = [];
        var Q = []; // Use Push and Shift for Queue operations
        var edgeTo = {};
        Q.push(startNodeID);
        var _loop_1 = function () {
            var x = Q.shift();
            if (!visisted.includes(x)) {
                visisted.push(x);
                G.getNodeAdjacency(x).forEach(function (y) {
                    if (!visisted.includes(y)) {
                        edgeTo[y] = x;
                        Q.push(y);
                    }
                });
            }
        };
        while (Q.length > 0) {
            _loop_1();
        }
        if (visisted.includes(targetNodeID)) {
            // Build the path
            var path = [];
            for (var x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {
                path.push(x);
            }
            path.push(startNodeID);
            path.reverse();
            // Get the path weight
            var weight = 0;
            for (var i = 0; i < path.length - 1; i++) {
                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);
            }
            return { pathExists: true, path: path, distance: path.length, weight: weight };
        }
        return { pathExists: false, path: [], distance: -1, weight: -1 };
    };
    GraphAlgorithms.dijkstraSearch = function (startNodeID, targetNodeID, G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        if (!G.isDirected()) {
            G = G.asDirected(true);
        }
        if (!G.isWeighted()) {
            G = G.asWeighted();
        }
        var nonNegative = G.getAllEdges(true).find(function (edge) {
            return edge.getWeight() < 0;
        });
        if (typeof nonNegative !== "undefined") {
            return false;
        }
        // Priority Queue implementation for Dijkstra
        var PriorityQueue = /** @class */ (function () {
            function PriorityQueue() {
                this._nodes = [];
            }
            PriorityQueue.prototype.enqueue = function (priority, key) {
                this._nodes.push({ key: key, priority: priority });
                this.sort();
            };
            PriorityQueue.prototype.dequeue = function () {
                return this._nodes.shift().key;
            };
            PriorityQueue.prototype.sort = function () {
                this._nodes.sort(function (a, b) {
                    return a.priority - b.priority;
                });
            };
            PriorityQueue.prototype.isEmpty = function () {
                return !this._nodes.length;
            };
            return PriorityQueue;
        }());
        var queue = new PriorityQueue();
        var distances = {};
        var previous = {};
        var path = [];
        // Initialize Queue and distances
        G.getAllNodes(true).forEach(function (node) {
            var dist = Infinity;
            if (node.getID() === startNodeID) {
                dist = 0;
            }
            distances[node.getID()] = dist;
            queue.enqueue(dist, node.getID());
            previous[node.getID()] = null;
        });
        var _loop_2 = function () {
            var smallest = queue.dequeue();
            if (smallest === targetNodeID) {
                path = [];
                while (previous[smallest] !== null) {
                    path.push(smallest);
                    smallest = previous[smallest];
                }
                return "break";
            }
            if (distances[smallest] === Infinity) {
                return "continue";
            }
            G.getNodeAdjacency(smallest).forEach(function (neighbor) {
                var alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);
                if (alt < distances[neighbor]) {
                    distances[neighbor] = alt;
                    previous[neighbor] = smallest;
                    queue.enqueue(alt, neighbor);
                }
            });
        };
        while (!queue.isEmpty()) {
            var state_1 = _loop_2();
            if (state_1 === "break")
                break;
        }
        path.push(startNodeID);
        path.reverse();
        if (distances[targetNodeID] !== Infinity) {
            return { pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID] };
        }
        return { pathExists: false, path: [], distance: -1, cost: 0 };
    };
    GraphAlgorithms.bellmanFord = function (startNodeID, targetNodeID, G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var distances = [];
        var parents = [];
        // Initialize
        G.getAllNodes(true).forEach(function (node) {
            distances[node.getID()] = Infinity;
            parents[node.getID()] = null;
        });
        // Relax Edges
        distances[startNodeID] = 0;
        for (var i = 0; i < G.getNumberOfNodes() - 1; i++) {
            G.getAllEdges(true).forEach(function (edge) {
                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {
                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();
                    parents[edge.getTo()] = edge.getFrom();
                }
            });
        }
        // Check for negative weight cycles
        var negativeCylce = false;
        G.getAllEdges(true).forEach(function (edge) {
            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {
                negativeCylce = true;
            }
        });
        if (distances[targetNodeID] !== Infinity) {
            var path = [targetNodeID];
            while (!path.includes(startNodeID)) {
                path.push(parents[path.slice().pop()]);
            }
            path.reverse();
            return { pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID] };
        }
        if (negativeCylce) {
            return false;
        }
        return { pathExists: false, path: [], distance: -1, cost: 0 };
    };
    GraphAlgorithms.fordFulkerson = function (startNodeID, targetNodeID, G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        // Must be a directed graph
        if (!G.isDirected()) {
            return false;
        }
        // Source == sink
        if (startNodeID === targetNodeID) {
            return false;
        }
        var bfs = GraphAlgorithms.breadthFirstSearch(startNodeID, targetNodeID, G);
        // No path from source to sink
        if (!bfs.pathExists) {
            return false;
        }
        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities
        G = G.reduceMultiGraph(function (a, b) {
            return a + b;
        }, 0);
        var V = G.getNumberOfNodes();
        var value = 0;
        var marked = [];
        var edgeTo = [];
        var edgeProperties = {};
        G.getAllEdges(true).forEach(function (edge) {
            edgeProperties[edge.getFrom() + "_" + edge.getTo()] = {
                from: edge.getFrom(),
                to: edge.getTo(),
                capacity: edge.getWeight(),
                flow: 0
            };
        });
        var other = function (e, x) {
            var edge = e.split("_");
            var a = parseInt(edge[0]);
            var b = parseInt(edge[1]);
            return x === a ? b : a;
        };
        var residualCapacity = function (e, x) {
            var edge = e.split("_");
            var a = parseInt(edge[0]);
            if (x === a) {
                return edgeProperties[e].flow;
            }
            return edgeProperties[e].capacity - edgeProperties[e].flow;
        };
        var addResidualFlow = function (e, x, deltaFlow) {
            var edge = e.split("_");
            var v = parseInt(edge[0]);
            if (x === v) {
                edgeProperties[e].flow -= deltaFlow;
            }
            else {
                edgeProperties[e].flow += deltaFlow;
            }
        };
        var hasAugmentedPath = function () {
            marked = [];
            edgeTo = [];
            for (var v = 0; v < V; ++v) {
                marked.push(false);
                edgeTo.push(null);
            }
            var queue = [];
            queue.push(startNodeID);
            marked[startNodeID] = true;
            while (queue.length > 0) {
                var v = queue.shift();
                var vertexAdjacency = G.getNodeAdjacency(v);
                for (var _i = 0, vertexAdjacency_2 = vertexAdjacency; _i < vertexAdjacency_2.length; _i++) {
                    var i = vertexAdjacency_2[_i];
                    var e = v + "_" + i;
                    var w = other(e, v);
                    if (!marked[w] && residualCapacity(e, w) > 0) {
                        edgeTo[w] = e;
                        marked[w] = true;
                        if (w === targetNodeID) {
                            return true;
                        }
                        queue.push(w);
                    }
                }
            }
            return false;
        };
        while (hasAugmentedPath()) {
            var bottleneckValue = Infinity;
            for (var x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {
                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x], x));
            }
            for (var x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {
                addResidualFlow(edgeTo[x], x, bottleneckValue);
            }
            value += bottleneckValue;
        }
        var getFlows = function () {
            var f = [];
            for (var v = 0; v < V; v++) {
                var vertexAdjacency = G.getNodeAdjacency(v);
                for (var _i = 0, vertexAdjacency_3 = vertexAdjacency; _i < vertexAdjacency_3.length; _i++) {
                    var i = vertexAdjacency_3[_i];
                    var e = v + "_" + i;
                    if (edgeProperties[e].flow > 0) {
                        f.push(edgeProperties[e]);
                    }
                }
            }
            return f;
        };
        return { maxFlow: value, flowPath: getFlows() };
    };
    GraphAlgorithms.kruskal = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        // If we have a multigraph, reduce it by using the minimum edge weights
        G.reduceMultiGraph();
        var Q = G.getAllEdges(true);
        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight
        Q.sort(function (a, b) {
            return a.getWeight() - b.getWeight();
        });
        var kruskal = [];
        var set = new _classes_SpanningTree__WEBPACK_IMPORTED_MODULE_2__["default"](G.getNumberOfNodes());
        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {
            var e = Q.shift();
            if (!set.connected(e.getFrom(), e.getTo())) {
                set.union(e.getFrom(), e.getTo());
                kruskal.push(e);
            }
        }
        // Get the total cost of the MST
        var weight = kruskal.reduce(function (acc, e) {
            return acc + e.getWeight();
        }, 0);
        return { mst: kruskal, totalWeight: weight };
    };
    GraphAlgorithms.topologicalSort = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        var adjacency = G.getFullAdjacency();
        var degrees = _util_graphHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].findVertexDegreesDirectional(adjacency);
        var L = [];
        var S = G.getAllNodes(true).filter(function (n) {
            return degrees[n.getID()].in === 0;
        });
        var edges = G.getAllEdges(true);
        var _loop_3 = function () {
            var nodeN = S.pop();
            L.push(nodeN);
            var nodeNConnectedTo = adjacency[nodeN.getID()];
            // Remove n to m edges for all nodes m
            edges = edges.filter(function (edge) {
                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {
                    degrees[edge.getTo()].in--;
                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter(function (v) {
                        return v !== edge.getTo();
                    });
                    return false;
                }
                return true;
            });
            // If m has no more incoming edges, add it to S
            nodeNConnectedTo.forEach(function (mID) {
                if (degrees[mID].in === 0) {
                    S.push(G.getNode(mID, true));
                }
            });
        };
        while (S.length !== 0) {
            _loop_3();
        }
        return edges.length > 0 || L;
    };
    GraphAlgorithms.isGraphCyclic = function (G) {
        if (G === void 0) { G = _graphState__WEBPACK_IMPORTED_MODULE_4__["default"].graph; }
        // If the topological sorting returns true, then it failed, so the graph has a cycle
        return GraphAlgorithms.topologicalSort(G) === true;
    };
    GraphAlgorithms.directionalEulerian = function (directionalDegrees, scc) {
        var eulerian = true;
        var component = -1;
        directionalDegrees.forEach(function (deg, id) {
            if (deg.in !== deg.out) {
                eulerian = false;
            }
            if (deg.in > 0) {
                if (component === -1) {
                    component = scc[id];
                }
                if (component !== scc[id]) {
                    eulerian = false;
                }
            }
        });
        return eulerian;
    };
    GraphAlgorithms.hasEulerianCircuit = function (degrees, cc) {
        var oddDegree = degrees.filter(function (v) {
            return v % 2 !== 0;
        });
        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian
        if (oddDegree.length !== 0) {
            return false;
        }
        var eulerian = true;
        var component = -1;
        degrees.forEach(function (v, i) {
            if (v !== 0) {
                if (component === -1) {
                    component = cc[i];
                }
                if (component !== cc[i]) {
                    eulerian = false;
                }
            }
        });
        return eulerian;
    };
    return GraphAlgorithms;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphAlgorithms);


/***/ }),

/***/ "./src/js/classes/SpanningTree.ts":
/*!****************************************!*\
  !*** ./src/js/classes/SpanningTree.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var SpanningTree = /** @class */ (function () {
    function SpanningTree(V) {
        this.id = [];
        for (var v = 0; v < V; v++) {
            this.id.push(v);
        }
    }
    SpanningTree.prototype.union = function (v, w) {
        var q = this.root(v);
        var p = this.root(w);
        if (p !== q) {
            this.id[p] = q;
        }
    };
    SpanningTree.prototype.root = function (q) {
        while (this.id[q] !== q) {
            q = this.id[q];
        }
        return q;
    };
    SpanningTree.prototype.connected = function (v, w) {
        return this.root(v) === this.root(w);
    };
    return SpanningTree;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpanningTree);


/***/ })

}]);
//# sourceMappingURL=src_js_GraphAlgorithms_ts-5e87e63d9c190a78f3e8.min.js.map