{"version":3,"file":"69-f2e2f2f99974dd3041b1.min.js","mappings":"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","sources":["webpack://graphPlayground/./src/js/GraphAlgorithms.ts","webpack://graphPlayground/./src/js/classes/SpanningTree.ts","webpack://graphPlayground/./src/js/workers/GraphAlgorithmWorker.ts"],"sourcesContent":["\"use strict\";\n\nimport genericH from \"./util/genericHelpers\";\nimport graphH from \"./util/graphHelpers\";\nimport SpanningTree from \"./classes/SpanningTree\";\nimport EdgeImmut, { EdgeImmutPlain } from \"./classes/GraphImmut/EdgeImmut\";\nimport NodeImmut from \"./classes/GraphImmut/NodeImmut\";\nimport GraphImmut from \"./classes/GraphImmut/GraphImmut\";\nimport GraphState from \"./graphState\";\nimport { GraphPlain } from \"./util/predefinedGraphs\";\nimport graphHelpers from \"./util/graphHelpers\";\n\ntype EdgeFlowProp = { from: number; to: number; capacity: number; flow: number };\nexport type MSTResult = { mst: EdgeImmutPlain[]; totalWeight: number };\nexport type FlowResult = { maxFlow: number; flowPath: EdgeFlowProp[] };\nexport type ShortestPathResult = {\n    pathExists: boolean;\n    path: number[];\n    distance: number;\n    cost?: number;\n    weight?: number;\n};\nexport type ConnectedComponentResult = { components: { [key: number]: number }; count: number };\n\nexport type CheckingColorResult = { from: number[]; to: number[]; num: number; confList: number[][]};\n\nexport type GetDegreesResult = { degrees: number[] };\n\nexport type kColorResult = { kColor: number; kColorable: boolean; color: number[]; totalSteps: number; history: number[][]};\n\nexport type kColorResultRecursive = { kColorable: boolean; color: number[]; totalSteps: number; history: number[][]};\n\nexport default class GraphAlgorithms {\n    public static graphPlainToGraphImmut = (gp: GraphPlain): GraphImmut => {\n        return new GraphImmut(gp.nodes, gp.edges, gp.directed, gp.weighted);\n    };\n\n\n    // // Coloring with brute force\n    // public static colorBruteForce = (G: GraphImmut = GraphState.graph) : {colors: {}; chromaticNumber: number} => {\n\n    //     // start with degree + 1\n\n    //     // check if k-colorable with brute force\n\n    // }\n\n    // Check, if a coloring is admissible\n    public static checkColoringByString = (G: GraphImmut = GraphState.graph): CheckingColorResult => {\n\n        const nodes = G.getAllNodes(true) as NodeImmut[];\n\n        const conflictStartID: number[] = [];\n        const conflictEndID: number[] = [];\n        const conflictList : number[][] = [];\n\n\n        const V = G.getNumberOfNodes();\n        for (let v = 0; v < V; v++) {\n            const vertexAdjacency = G.getNodeAdjacency(v);\n            const currentColor = nodes[v].getAttribute('color');\n\n            //console.log(\"Vertex with ID\" + v);\n            //console.log(\"has adjacency: \" + vertexAdjacency);\n\n            for (const i of vertexAdjacency) {\n                const conflict  = graphH.compareColor(currentColor, nodes[i].getAttribute('color'));\n                if (conflict && i > v) {\n                    conflictStartID.push(v);\n                    conflictEndID.push(i);\n                    conflictList.push([v, i]);\n                }\n            }\n        }\n        \n        const numOfConflicts = conflictStartID.length;\n\n        return { from: conflictStartID, to: conflictEndID,  num: numOfConflicts, confList: conflictList};\n\n    }\n\n    public static getAllDegreesWrapper = (G: GraphImmut = GraphState.graph): GetDegreesResult => {\n        \n        const arr1 = G.getAllInOutDegrees();\n        // const arr = [...arr1];\n\n        // // console.log(arr1);\n        // console.log(arr);\n        \n        return { degrees: arr1 };\n    }\n\n    public static colorNetworkGreedy = (orderingMode: string, G: GraphImmut = GraphState.graph): { colors: {}; vertexOrder: number[]; chromaticNumber: number; history: { nodeToColor: number; colorsOfNeighbors: { [key: number]: number; }; }[]} => {\n        \n        const V = G.getNumberOfNodes();\n        \n        // Get node ID's only\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\n\n        const degrees = G.getAllInOutDegrees();\n        const nodeArrLabel: string[] = genericH.datasetToArray(G.getAllNodes(), \"label\") as string[];\n\n        // console.log(nodeArr);\n        // console.log(degrees);\n\n        // Put vertices in array in decreasing order of degree\n        \n        // console.log(orderingMode);\n        // console.log(nodeArr);\n        // console.log(nodeArrLabel);\n\n        let vertexOrder: number[] = [];\n\n        if (orderingMode === \"1\") {\n            // Put vertices in the increasing order of their label.\n            vertexOrder = genericH.sort(nodeArr, (a, b) => {\n                return (nodeArrLabel[a].toLowerCase()).localeCompare(nodeArrLabel[b].toLowerCase());\n            });\n            // console.log(\"Ordering 1\");\n        }\n        else if (orderingMode === \"2\") {\n            // Put vertices in the decreasing order of their id.\n            vertexOrder = genericH.sort(nodeArr, (a, b) => {\n                return (-1)* (nodeArrLabel[a].toLowerCase()).localeCompare(nodeArrLabel[b].toLowerCase());\n            });\n            // console.log(\"Ordering 2\");\n        }\n        else if (orderingMode === \"3\") {\n            // Put vertices in array in decreasing order of degree            \n            vertexOrder = genericH.sort(nodeArr, (a, b) => {\n                return degrees[a] > degrees[b] ? 1 : (degrees[a] === degrees[b] ? 0 : -1);\n            });\n            \n            // console.log(\"Ordering 3\");\n        }\n        else if (orderingMode === \"4\") {\n            // Put vertices in array in decreasing order of degree\n            vertexOrder = genericH.sort(nodeArr, (a, b) => {\n                return degrees[a] < degrees[b] ? 1 : (degrees[a] === degrees[b] ? 0 : -1);\n            });\n            // console.log(\"Ordering 4\");\n        }\n        else {\n            console.log(\"No valid orderingMode\");\n            // console.log(typeof orderingMode);\n            // console.log(orderingMode);\n        }\n        // console.log(vertexOrder);\n        \n\n        const history = [];\n        const colors = {};\n\n        const colorIndex: { [key: number]: number } = {};\n\n        // initalize vertices as unassigned\n        for (let i=0; i < V; i++) {\n            colorIndex[i] = -1;\n        }\n\n        // only for history\n        const vertexAdjacency = G.getNodeAdjacency(vertexOrder[0]);\n        const coloredAdjacencyList: { [key: number]: number } = {};\n        for (const index in vertexAdjacency) {\n            coloredAdjacencyList[vertexAdjacency[index]] = colorIndex[vertexAdjacency[index]];\n        }\n        history.push({nodeToColor: vertexOrder[0], colorsOfNeighbors: coloredAdjacencyList});\n\n        // set color for first node to 0\n        colorIndex[vertexOrder[0]] = 0;\n\n        for (let curPos=1; curPos < V; curPos++){\n\n            const vertexAdjacency = G.getNodeAdjacency(vertexOrder[curPos]);\n            const coloredAdjacencyList: { [key: number]: number } = {};\n            for (const index in vertexAdjacency) {\n                coloredAdjacencyList[vertexAdjacency[index]] = colorIndex[vertexAdjacency[index]];\n            }\n            // create history\n            history.push({nodeToColor: vertexOrder[curPos], colorsOfNeighbors: coloredAdjacencyList});\n\n            //\n            const allUsedColors= Object.values(coloredAdjacencyList);\n            const ref :{ [key: number]: boolean } = {};\n    \n            let minimalMissingColor  = 0;\n            \n            for (const value of allUsedColors) {\n                if (value < minimalMissingColor) {\n                    continue;\n                }\n                ref[value] = true;\n\n                while (ref[minimalMissingColor]) {\n                    minimalMissingColor++;\n                }\n            }\n            // console.log(\"==============\");\n            // console.log(\"Current Node: \" + curPos);\n            // console.log(vertexAdjacency);\n            // console.log(coloredAdjacencyList);\n            // console.log(allUsedColors);\n            // console.log(\"Minimal missing color: \" + minimalMissingColor);\n\n            colorIndex[vertexOrder[curPos]] = minimalMissingColor;\n\n            // console.log(colorIndex);\n\n        }\n\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\n        // return { colors: colorIndex, chromaticNumber, history};\n        return { colors: colorIndex, vertexOrder, chromaticNumber, history };\n    };\n\n    // Welsh-Powell Algorithm\n    public static colorNetworkWelsh = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number} => {\n        // Get node ID's only\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\n\n        // Put vertices in array in decreasing order of degree\n        const degrees = G.getAllOutDegrees();\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\n        });\n\n        const colorIndex: { [key: number]: number } = {};\n        let currentColor = 0;\n        while (vertexOrder.length > 0) {\n            const root = vertexOrder.shift()!;\n            colorIndex[root] = currentColor;\n\n            const myGroup = [];\n            myGroup.push(root);\n\n            for (let i = 0; i < vertexOrder.length; ) {\n                const p = vertexOrder[i];\n                let conflict = false;\n                \n                for (let j = 0; j < myGroup.length; j++) {\n                    if (G.areAdjacent(p, myGroup[j])) {\n                        i++;\n                        conflict = true;\n                        break;\n                    }\n                }\n                if (conflict) {\n                    continue;\n                }\n\n                colorIndex[p] = currentColor;\n                myGroup.push(p);\n                vertexOrder.splice(i, 1);\n            }\n\n            currentColor++;\n        }\n\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\n        return { colors: colorIndex, chromaticNumber};\n    };\n\n    \n\n    public static kColoringExact = (mode: number, completeColoring: boolean, kColor: number, numberOfSteps: number, G: GraphImmut = GraphState.graph): kColorResult => {\n\n        const kColoringBacktrackingRecursive = (kColor: number, mode: number, curNode: number, color: number[], given: boolean[], G: GraphImmut, totalSteps: number, maxHist: number, history: number[][]): kColorResultRecursive => {\n            \n            const V = G.getNumberOfNodes();\n            \n            // console.log(\"CurNode: \" + curNode + \" with colors \" + color);\n\n            if (curNode === V) {\n                return { kColorable: true, color, totalSteps, history};\n            }\n\n            for (let j = 0 + mode ; j < kColor + mode; j++) {\n                \n                console.log(\"CurNode: \" + curNode + \"; CurColor: \" + j);\n                console.log(color);\n\n                if (given[curNode] && j !== color[curNode]) {\n                    continue;\n                }\n\n                totalSteps++;\n\n                const check = graphHelpers.nextColorIsSafe(curNode, G, color, j);\n                let colorHistory = [...color];\n                colorHistory[curNode] = j;\n\n                if (totalSteps <= maxHist) {\n                    history.push([...colorHistory]);\n                }\n\n                if (check) {\n                    color[curNode] = j;\n\n                    const recAnswer = kColoringBacktrackingRecursive(kColor, mode, curNode+1, color, given, G, totalSteps, maxHist, history);\n\n                    if (recAnswer.kColorable) {\n                        return recAnswer;\n                    }\n\n                    totalSteps = recAnswer.totalSteps;\n                    history = recAnswer.history;\n\n                }\n                \n                if (curNode === 0) {\n                    console.log(\"Color of vertex 0: \" + color[0]);\n                }\n\n                if (!given[curNode]) {\n                    color[curNode] = -1;\n                }\n\n            }\n    \n            return { kColorable: false, color: [], totalSteps, history};\n    \n        }\n\n        const kColoringBruteForceRecursive = (kColor: number, curNode: number, color: number[], G: GraphImmut, totalSteps: number, maxHist: number, history: number[][]): kColorResultRecursive => {\n            \n            const V = G.getNumberOfNodes();\n            \n            // console.log(\"CurNode: \" + curNode + \" with colors \" + color);\n\n            if (curNode === V) {\n                const check = graphHelpers.checkColoringByNumber(color, G);\n                totalSteps += 1;\n                if (totalSteps <= maxHist) {\n                    history.push([...color]);\n                }\n                if (check) {            \n                    return { kColorable: true, color, totalSteps, history};\n                }\n                else {\n                    return { kColorable: false, color: [], totalSteps, history};\n                }\n            }\n    \n            for (let j=0; j < kColor; j++) {\n                color[curNode] = j;\n    \n                const recAnswer = kColoringBruteForceRecursive(kColor, curNode+1, color, G, totalSteps, maxHist, history);\n    \n                if (recAnswer.kColorable) {\n                    return recAnswer;\n                }\n    \n                color[curNode] = -1;\n                totalSteps = recAnswer.totalSteps;\n                history = recAnswer.history;\n    \n            }\n    \n            return { kColorable: false, color: [], totalSteps, history};\n    \n        }\n\n        const V = G.getNumberOfNodes();\n        const color = new Array(V).fill(-1);\n        const given = new Array(V).fill(false);\n\n        if (completeColoring) {\n            const givenColorList : { [node: number] : number } = G.getNonDefaultColor();\n            Object.entries(givenColorList).forEach(\n                ([key, value]) =>  {\n                    let index = (key as unknown) as number;\n                    // console.log(key, value);\n                    color[index] = value;\n                    given[index] = true;\n                }\n              );\n        }\n\n        console.log(\"kColoringExact\");\n        console.log(color);\n        console.log(given);\n\n        const history : number[][] = [];\n\n        let recAnswer : kColorResultRecursive = {kColorable: false, color: [], totalSteps: 0, history: []};\n\n        if (mode !== 1) {\n            mode = 0;\n            recAnswer = kColoringBruteForceRecursive(kColor, 0, color, G, 0, numberOfSteps, history);\n        }\n        else if (mode === 1) {\n            recAnswer = kColoringBacktrackingRecursive(kColor, mode, 0, color, given, G, 0, numberOfSteps, history);\n        }\n\n        // console.log(\"Finished Exact Algorithm\");\n\n        if (recAnswer.kColorable) {\n            return { kColor, kColorable: true, color: recAnswer.color, totalSteps: recAnswer.totalSteps, history };\n        }\n\n        return { kColor, kColorable: false, color: [], totalSteps: recAnswer.totalSteps, history };\n    }\n\n\n    public static connectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        \n        // console.log(\"Hi, I'm connectedComponents\");\n        \n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n        const setComponentNum = (v: number) => {\n            components[v] = componentCount;\n        };\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in components)) {\n                const visited = GraphAlgorithms.depthFirstSearch(i, G);\n                visited.forEach(setComponentNum);\n                componentCount++;\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static depthFirstSearch = (start: number, G = GraphState.graph): number[] => {\n        const visisted: number[] = [];\n        const Stack: number[] = [];\n        Stack.push(start);\n        while (Stack.length > 0) {\n            const v = Stack.pop()!;\n            if (!visisted.includes(v)) {\n                visisted.push(v);\n                G.getNodeAdjacency(v).forEach(nodeID => {\n                    Stack.push(nodeID);\n                });\n            }\n        }\n\n        return visisted;\n    };\n\n    // Tarjan's algorithm\n    public static stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        let index = 0;\n        const indices: { [key: number]: number } = {};\n        const lowlink: { [key: number]: number } = {};\n        const S: number[] = [];\n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n\n        const strongConnect = (v: number) => {\n            indices[v] = index;\n            lowlink[v] = index++;\n            S.push(v);\n\n            G.getNodeAdjacency(v).forEach(w => {\n                if (!(w in indices)) {\n                    strongConnect(w);\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\n                } else if (S.includes(w)) {\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\n                }\n            });\n\n            if (lowlink[v] === indices[v]) {\n                let w = -1;\n                if (S.length > 0) {\n                    do {\n                        w = S.pop()!;\n                        components[w] = componentCount;\n                    } while (w !== v);\n                    componentCount++;\n                }\n            }\n        };\n\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in indices)) {\n                strongConnect(i);\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static breadthFirstSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult => {\n        // Perform the BFS\n        const visisted: number[] = [];\n        const Q: number[] = []; // Use Push and Shift for Queue operations\n        const edgeTo: { [key: number]: number } = {};\n\n        Q.push(startNodeID);\n        while (Q.length > 0) {\n            const x = Q.shift()!;\n            if (!visisted.includes(x)) {\n                visisted.push(x);\n                G.getNodeAdjacency(x).forEach(y => {\n                    if (!visisted.includes(y)) {\n                        edgeTo[y] = x;\n                        Q.push(y);\n                    }\n                });\n            }\n        }\n\n        if (visisted.includes(targetNodeID)) {\n            // Build the path\n            const path = [];\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\n                path.push(x);\n            }\n            path.push(startNodeID);\n            path.reverse();\n\n            // Get the path weight\n            let weight = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\n            }\n\n            return { pathExists: true, path, distance: path.length, weight };\n        }\n\n        return { pathExists: false, path: [], distance: -1, weight: -1 };\n    };\n\n    public static dijkstraSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        if (!G.isDirected()) {\n            G = G.asDirected(true);\n        }\n        if (!G.isWeighted()) {\n            G = G.asWeighted();\n        }\n\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find(edge => {\n            return edge.getWeight() < 0;\n        });\n        if (typeof nonNegative !== \"undefined\") {\n            return false;\n        }\n\n        // Priority Queue implementation for Dijkstra\n        class PriorityQueue {\n            private readonly _nodes: { key: number | string; priority: number }[] = [];\n\n            enqueue(priority: number, key: number): void {\n                this._nodes.push({ key, priority });\n                this.sort();\n            }\n\n            dequeue(): number | string {\n                return this._nodes.shift()!.key;\n            }\n\n            sort(): void {\n                this._nodes.sort((a: { priority: number }, b: { priority: number }) => {\n                    return a.priority - b.priority;\n                });\n            }\n\n            isEmpty(): boolean {\n                return !this._nodes.length;\n            }\n        }\n\n        const queue = new PriorityQueue();\n        const distances: { [key: number]: number } = {};\n        const previous: { [key: number]: number | null } = {};\n        let path = [];\n\n        // Initialize Queue and distances\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            let dist = Infinity;\n            if (node.getID() === startNodeID) {\n                dist = 0;\n            }\n\n            distances[node.getID()] = dist;\n            queue.enqueue(dist, node.getID());\n            previous[node.getID()] = null;\n        });\n\n        while (!queue.isEmpty()) {\n            let smallest = queue.dequeue() as number;\n\n            if (smallest === targetNodeID) {\n                path = [];\n                while (previous[smallest] !== null) {\n                    path.push(smallest);\n                    smallest = previous[smallest]!;\n                }\n                break;\n            }\n\n            if (distances[smallest] === Infinity) {\n                continue;\n            }\n\n            G.getNodeAdjacency(smallest).forEach(neighbor => {\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\n\n                if (alt < distances[neighbor]) {\n                    distances[neighbor] = alt;\n                    previous[neighbor] = smallest;\n\n                    queue.enqueue(alt, neighbor);\n                }\n            });\n        }\n\n        path.push(startNodeID);\n        path.reverse();\n\n        if (distances[targetNodeID] !== Infinity) {\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static bellmanFord = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        const distances: number[] = [];\n        const parents: (number | null)[] = [];\n\n        // Initialize\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            distances[node.getID()] = Infinity;\n            parents[node.getID()] = null;\n        });\n\n        // Relax Edges\n        distances[startNodeID] = 0;\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\n            (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\n                    parents[edge.getTo()] = edge.getFrom();\n                }\n            });\n        }\n\n        // Check for negative weight cycles\n        let negativeCylce = false;\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                negativeCylce = true;\n            }\n        });\n\n        if (distances[targetNodeID] !== Infinity) {\n            const path: number[] = [targetNodeID];\n            while (!path.includes(startNodeID)) {\n                path.push(parents[path.slice().pop()!] as number);\n            }\n            path.reverse();\n\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        if (negativeCylce) {\n            return false;\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static fordFulkerson = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): boolean | FlowResult => {\n        // Must be a directed graph\n        if (!G.isDirected()) {\n            return false;\n        }\n\n        // Source == sink\n        if (startNodeID === targetNodeID) {\n            return false;\n        }\n\n        const bfs = GraphAlgorithms.breadthFirstSearch(startNodeID, targetNodeID, G);\n        // No path from source to sink\n        if (!bfs.pathExists) {\n            return false;\n        }\n\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\n        G = G.reduceMultiGraph((a, b) => {\n            return a + b;\n        }, 0);\n\n        const V = G.getNumberOfNodes();\n        let value = 0;\n        let marked: boolean[] = [];\n        let edgeTo: (string | null)[] = [];\n\n        const edgeProperties: { [key: string]: EdgeFlowProp } = {};\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\n                from: edge.getFrom(),\n                to: edge.getTo(),\n                capacity: edge.getWeight(),\n                flow: 0\n            };\n        });\n\n        const other = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            const b = parseInt(edge[1]);\n            return x === a ? b : a;\n        };\n\n        const residualCapacity = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            if (x === a) {\n                return edgeProperties[e].flow;\n            }\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\n        };\n\n        const addResidualFlow = (e: string, x: number, deltaFlow: number) => {\n            const edge = e.split(\"_\");\n            const v = parseInt(edge[0]);\n            if (x === v) {\n                edgeProperties[e].flow -= deltaFlow;\n            } else {\n                edgeProperties[e].flow += deltaFlow;\n            }\n        };\n\n        const hasAugmentedPath = () => {\n            marked = [];\n            edgeTo = [];\n            for (let v = 0; v < V; ++v) {\n                marked.push(false);\n                edgeTo.push(null);\n            }\n\n            const queue = [];\n            queue.push(startNodeID);\n\n            marked[startNodeID] = true;\n            while (queue.length > 0) {\n                const v = queue.shift()!;\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    const w = other(e, v);\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\n                        edgeTo[w] = e;\n                        marked[w] = true;\n                        if (w === targetNodeID) {\n                            return true;\n                        }\n\n                        queue.push(w);\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        while (hasAugmentedPath()) {\n            let bottleneckValue = Infinity;\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x]!, x));\n            }\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                addResidualFlow(edgeTo[x]!, x, bottleneckValue);\n            }\n            value += bottleneckValue;\n        }\n\n        const getFlows = (): EdgeFlowProp[] => {\n            const f: EdgeFlowProp[] = [];\n            for (let v = 0; v < V; v++) {\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    if (edgeProperties[e].flow > 0) {\n                        f.push(edgeProperties[e]);\n                    }\n                }\n            }\n\n            return f;\n        };\n\n        return { maxFlow: value, flowPath: getFlows() };\n    };\n\n    public static kruskal = (G: GraphImmut = GraphState.graph): MSTResult => {\n        // If we have a multigraph, reduce it by using the minimum edge weights\n        G.reduceMultiGraph();\n\n        const Q: EdgeImmut[] = G.getAllEdges(true) as EdgeImmut[];\n\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\n        Q.sort((a, b) => {\n            return a.getWeight() - b.getWeight();\n        });\n\n        const kruskal: EdgeImmut[] = [];\n        const set = new SpanningTree(G.getNumberOfNodes());\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\n            const e = Q.shift()!;\n            if (!set.connected(e.getFrom(), e.getTo())) {\n                set.union(e.getFrom(), e.getTo());\n                kruskal.push(e);\n            }\n        }\n\n        // Get the total cost of the MST\n        const weight = kruskal.reduce((acc, e) => {\n            return acc + e.getWeight();\n        }, 0);\n\n        return { mst: (kruskal as any) as EdgeImmutPlain[], totalWeight: weight };\n    };\n\n    public static topologicalSort = (G: GraphImmut = GraphState.graph): boolean | NodeImmut[] => {\n        const adjacency = G.getFullAdjacency();\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\n\n        const L: NodeImmut[] = [];\n        const S: NodeImmut[] = (G.getAllNodes(true) as NodeImmut[]).filter(n => {\n            return degrees[n.getID()].in === 0;\n        });\n        let edges = G.getAllEdges(true) as EdgeImmut[];\n\n        while (S.length !== 0) {\n            const nodeN = S.pop()!;\n            L.push(nodeN);\n\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\n\n            // Remove n to m edges for all nodes m\n            edges = edges.filter(edge => {\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\n                    degrees[edge.getTo()].in--;\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter(v => {\n                        return v !== edge.getTo();\n                    });\n                    return false;\n                }\n                return true;\n            });\n\n            // If m has no more incoming edges, add it to S\n            nodeNConnectedTo.forEach(mID => {\n                if (degrees[mID].in === 0) {\n                    S.push(G.getNode(mID, true) as NodeImmut);\n                }\n            });\n        }\n\n        return edges.length > 0 || L;\n    };\n\n    public static isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\n        return GraphAlgorithms.topologicalSort(G) === true;\n    };\n\n    public static directionalEulerian = (directionalDegrees: { in: number; out: number }[], scc: number[]): boolean => {\n        let eulerian = true;\n        let component = -1;\n        directionalDegrees.forEach((deg, id) => {\n            if (deg.in !== deg.out) {\n                eulerian = false;\n            }\n            if (deg.in > 0) {\n                if (component === -1) {\n                    component = scc[id];\n                }\n                if (component !== scc[id]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n\n    public static hasEulerianCircuit = (degrees: number[], cc: number[]): boolean => {\n        const oddDegree = degrees.filter(v => {\n            return v % 2 !== 0;\n        });\n\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\n        if (oddDegree.length !== 0) {\n            return false;\n        }\n\n        let eulerian = true;\n        let component = -1;\n        degrees.forEach((v, i) => {\n            if (v !== 0) {\n                if (component === -1) {\n                    component = cc[i];\n                }\n                if (component !== cc[i]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n}\n","\"use strict\";\n\nexport default class SpanningTree {\n    private readonly id: number[];\n\n    constructor(V: number) {\n        this.id = [];\n        for (let v = 0; v < V; v++) {\n            this.id.push(v);\n        }\n    }\n\n    union(v: number, w: number) {\n        const q = this.root(v);\n        const p = this.root(w);\n\n        if (p !== q) {\n            this.id[p] = q;\n        }\n    }\n\n    root(q: number) {\n        while (this.id[q] !== q) {\n            q = this.id[q];\n        }\n        return q;\n    }\n\n    connected(v: number, w: number) {\n        return this.root(v) === this.root(w);\n    }\n}\n","import GraphAlgorithms from \"../GraphAlgorithms\";\nconst ctx: Worker = self as any;\n\nlet myID: number;\n\nfunction sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nctx.addEventListener(\"message\", async e => {\n    if (e.data.type === \"id\") {\n        myID = e.data.id;\n        return;\n    }\n    const args: any[] = e.data.args;\n    if (e.data.type === \"test\") {\n        await sleep(e.data.waitTime);\n        ctx.postMessage({ id: myID, data: \"DONE\" });\n        return;\n    }\n    if (\"convertToGraphImmut\" in e.data && e.data.convertToGraphImmut) {\n        args.push(GraphAlgorithms.graphPlainToGraphImmut(e.data.graph));\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\n    } else {\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\n    }\n});\n"],"names":["graphPlainToGraphImmut","gp","nodes","edges","directed","weighted","checkColoringByString","G","getAllNodes","conflictStartID","conflictEndID","conflictList","V","getNumberOfNodes","v","vertexAdjacency","getNodeAdjacency","currentColor","getAttribute","i","push","from","to","num","length","confList","getAllDegreesWrapper","degrees","getAllInOutDegrees","colorNetworkGreedy","orderingMode","nodeArr","nodeArrLabel","vertexOrder","a","b","toLowerCase","localeCompare","console","log","history","colorIndex","coloredAdjacencyList","index","nodeToColor","colorsOfNeighbors","curPos","ref","minimalMissingColor","Object","values","value","colors","chromaticNumber","colorNetworkWelsh","getAllOutDegrees","root","shift","myGroup","p","conflict","j","areAdjacent","splice","kColoringExact","mode","completeColoring","kColor","numberOfSteps","kColoringBacktrackingRecursive","curNode","color","given","totalSteps","maxHist","kColorable","check","colorHistory","kColoringBruteForceRecursive","Array","fill","givenColorList","getNonDefaultColor","entries","forEach","key","recAnswer","connectedComponents","components","componentCount","setComponentNum","GraphAlgorithms","depthFirstSearch","count","start","visisted","Stack","pop","includes","nodeID","stronglyConnectedComponents","indices","lowlink","S","strongConnect","w","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","queue","_nodes","enqueue","priority","this","sort","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","reduceMultiGraph","marked","edgeProperties","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","bottleneckValue","maxFlow","flowPath","f","getFlows","kruskal","set","connected","union","reduce","acc","mst","totalWeight","topologicalSort","adjacency","getFullAdjacency","L","filter","n","in","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","scc","eulerian","component","deg","id","out","hasEulerianCircuit","cc","q","myID","ctx","self","addEventListener","data","type","args","ms","waitTime","Promise","resolve","setTimeout","postMessage","convertToGraphImmut","graph","apply"],"sourceRoot":""}